#!/bin/bash
#
#+Functions for data type checks and conversions.
#+
#+Copyright (C) 2021  David Hobach  LGPLv3
#+0.5

b_deps "mktemp" "mkfifo" "rm" "wc" "python3" "tee" "head"

#+### Global Variables ###

#+B_TYPES_ENCODINGS
#+Deprecated global map for human readable string encodings which can be used for [b_types_parseString](#b_typesParseString).
declare -gA B_TYPES_ENCODINGS=(
	["7-bit"]="ascii"
	["8-bit"]="latin1"
	["16-bit-bigendian"]="unsupported"
	["16-bit-littleendian"]="unsupported"
	["32-bit-bigendian"]="unsupported"
	["32-bit-littleendian"]="unsupported"
	)

#+### Functions ###

#+b_types_parseString [encoding]
#+Checks whether whatever is lying in stdin is a string (and not binary) and if so, prints it to stdout.
#+
#+**Important**:
#+
#+ * bash has major issues whenever binary data is involved. For example equality checks may return undefined results. So whenever you are unsure as to whether a variable is a string or not, better pass it thorugh this function.
#+ * The input is taken from *stdin* rather than as parameter as binary parameters may also cause issues (special bytes etc.).
#+ * Even builtins such as `echo` do not necessarily play well with binary data. So it is recommended to pipe binary data through this function before further processing.
#+
#+Examples:
#+```bash
#+ #check a file
#+ b_types_parseString < "/path/to/potential/binary" > /dev/null && echo "It is a string file." || echo "It is a binary file."
#+
#+ #read parts of a file as string
#+ str="$(dd if="/path/to/another/file" bs=1 skip=8 | b_types_parseString)"
#+ [ $? -eq 0 ] && echo "Found the following string: $str"
#+```
#+
#+[encoding]: The encoding of the string lying in stdin. Defaults to `ascii`, which makes sense in 99% of all cases as scripts should use ASCII only anyway (when no user-interaction is involved) in order to remain portable. Keep in mind that bash also needs to support the target encoding in order to support further processing. Currently available encodings: <https://docs.python.org/3.7/library/codecs.html#standard-encodings>
#+returns: The data as String, if the input data was found to be a String. If no String was found to be lying in stdin, the output is an undefined string and a non-zero exit code is set. [B_E](#B_E) is only called on exceptional errors.
#+@B_E
function b_types_parseString {
local encoding="${1:-"ascii"}"

if [ -z "$encoding" ] || [[ "$encoding" == "unsupported" ]] ; then
	B_ERR="This encoding is no longer supported. Please migrate to the new syntax."
	B_E
fi

local readStr="${BLIB_STORE["BLIB_UTIL_DIR"]}/read_str"

local ret=
#NOTE: We use the more type safe python for this job. Even `strings` had vulnerabilities in the past and is less precise wrt encodings anyway.
python3 "$readStr" --encoding "$encoding" 2> /dev/null
ret=$?
[ $ret -eq 6 ] && B_ERR="Unknown encoding: $encoding" && B_E
return $ret
}

#+b_types_isInteger [string]
#+Check whether the given String is an integer (positive or negative) or not.
#+[string]: The string to check. If it may be binary data, please make sure to pass it through [b_types_parseString](#b_types_parseString) first.
#+returns: Nothing, but sets a zero exit code if and only if the given string represents an integer.
function b_types_isInteger {
printf "%d" "$1" &> /dev/null
}

#+b_types_assertInteger [string] [error msg]
#+Check whether the given String is an integer (positive or negative) and if not, error out.
#+[string]: The string to check. If it may be binary data, please make sure to pass it through [b_types_parseString](#b_types_parseString) first.
#+[error msg]: Error message to use, if the check fails (optional).
#+returns: Nothing. If it's no integer, [B_E](#B_E) is called.
#+@B_E
function b_types_assertInteger {
b_types_isInteger "$1" || { B_ERR="${2:-"No integer: $1"}" ; B_E }
}

#+b_types_looksLikeArray [string]
#+Check whether the given String "looks like" a bash array or not.
#+It may still contain malicious code or whatnot. So you **must not** rely on this function when processing untrusted input.
#+[string]: The string to check. Use `"$(declare -p var)"` on variables to obtain it.
#+returns: Nothing, but sets a zero exit code if the given string looks like it could be `eval`'ed to a bash array.  References (`declare -n`) will result in a non-zero exit code.
function b_types_looksLikeArray {
local str="$1"
local declareWithOpts='declare[ ]+\-([aglrtux]+)'
local aname='([a-zA-Z_][a-zA-Z0-9_]*)'
local contentPart="$aname=['\"]?\\((.*)\\)['\"]?"
local re='^[ ]*'"$declareWithOpts"'[ ]+'"$contentPart"'[ ]*$'
if [[ "$str" =~ $re ]] ; then
	[[ "${BASH_REMATCH[1]}" == *"a"* ]] || return 1
	#NOTE: in order to make sure it is actually an array, we'd have to fully parse the content - which is hard
	return 0
fi

#variant: empty array with declare
local re='^[ ]*'"$declareWithOpts"'[ ]+'"$aname"'[ ]*$'
if [[ "$str" =~ $re ]] ; then
	[[ "${BASH_REMATCH[1]}" == *"a"* ]] || return 1
	return 0
fi

#variant: declare, no options
local re='^[ ]*declare[ ]+'"$contentPart"'[ ]*$'
[[ "$str" =~ $re ]] && return 0

#variant: no declare, no options
local re='^[ ]*'"$contentPart"'[ ]*$'
[[ "$str" =~ $re ]] && return 0

return 1
}

#+b_types_assertLooksLikeArray [string] [error msg]
#+Check whether the given String "looks like" a bash array and if not, error out.
#+It may still contain malicious code or whatnot. So you **must not** rely on this function when processing untrusted input.
#+[string]: The string to check. Use `"$(declare -p var)"` on variables to obtain it.
#+[error msg]: Error message to use, if the check fails (optional).
#+returns: Nothing. If doesn't look like a bash array, [B_E](#B_E) is called.
#+@B_E
function b_types_assertLooksLikeArray {
b_types_looksLikeArray "$1" || { B_ERR="${2:-"Doesn't look like a bash array: $1"}" ; B_E }
}

#+b_types_looksLikeMap [string]
#+Check whether the given String "looks like" a bash map / associative array or not.
#+It may still contain malicious code or whatnot. So you **must not** rely on this function when processing untrusted input.
#+[string]: The string to check. Use `"$(declare -p var)"` on variables to obtain it.
#+returns: Nothing, but sets a zero exit code if the given string looks like it could be `eval`'ed to a bash associative array. References (`declare -n`) will result in a non-zero exit code.
function b_types_looksLikeMap {
local str="$1"
local declareWithOpts='declare[ ]+\-([Aglrtux]+)'
local aname='([a-zA-Z_][a-zA-Z0-9_]*)'
local re='^[ ]*'"$declareWithOpts"'[ ]+'"$aname=['\"]?\\((.*)\\)['\"]?[ ]*$"
if [[ "$str" =~ $re ]] ; then
	[[ "${BASH_REMATCH[1]}" == *"A"* ]] || return 1
	#NOTE: in order to make sure it is actually a map, we'd have to fully parse the content - which is hard
	return 0
fi

#variant: empty array with declare
local re='^[ ]*'"$declareWithOpts"'[ ]+'"$aname"'[ ]*$'
if [[ "$str" =~ $re ]] ; then
	[[ "${BASH_REMATCH[1]}" == *"A"* ]] || return 1
	return 0
fi

return 1
}

#+b_types_assertLooksLikeMap [string] [error msg]
#+Check whether the given String "looks like" a bash map / associative array and if not, error out.
#+It may still contain malicious code or whatnot. So you **must not** rely on this function when processing untrusted input.
#+[string]: The string to check. Use `"$(declare -p var)"` on variables to obtain it.
#+[error msg]: Error message to use, if the check fails (optional).
#+returns: Nothing. If doesn't look like a bash array, [B_E](#B_E) is called.
#+@B_E
function b_types_assertLooksLikeMap {
b_types_looksLikeMap "$1" || { B_ERR="${2:-"Doesn't look like a bash map: $1"}" ; B_E }
}
