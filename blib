#!/bin/bash
#
#+blib - a bash library
#+
#+The basic functions which are imported by default.
#+
#+Copyright (C) 2018  David Hobach  LGPLv3
#+version: Execute `blib version` or use [b_version](#b_version).
#+
#+### Disclaimer ###
#+This program is free software: you can redistribute it and/or modify
#+it under the terms of the Lesser GNU General Public License as published by
#+the Free Software Foundation, either version 3 of the License, or
#+(at your option) any later version.
#+
#+This program is distributed in the hope that it will be useful,
#+but WITHOUT ANY WARRANTY; without even the implied warranty of
#+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#+Lesser GNU General Public License for more details.
#+
#+You should have received a copy of the Lesser GNU General Public License
#+along with this program.  If not, see <https://www.gnu.org/licenses/>.
#+
#+**The above statements apply to all modules of blib if not mentioned otherwise.**
#+
#+### Coding Conventions ###
#+ #.   embrace the KISS principle
#+ #.   some general guidelines: <http://www.kfirlavi.com/blog/2012/11/14/defensive-bash-programming/>
#+ #.   use b\_\[module\]\_\[camel case function name\] to denote functions meant to be used by users of the library, B_\[module\]\_\[upper case var name\] for global variables
#+ #.   use BLIB\_\[module\]\_\[upper case var name\] for global variables (to be avoided whenever possible) not meant to be used by library users ("private" variables); library users can use setters or getters
#+ #.   use the BLIB\_STORE with the above naming conventions for "private" variables whenever possible
#+ #.   use blib\_\[module\]\_\[camel case function name\] to denote private functions not meant to be used by library users; the function name should not contain any underscores
#+ #.   the blib module itself is the only exception which can use b_, B_, blib_, BLIB_ without module name
#+ #.   prefixes such as t_, T_ and UTD_ are exclusively related to test code
#+ #.   set exit codes (!= 0 --> issue) wherever it makes sense
#+ #.   keep the global namespace clean whenever possible
#+ #.   declare -g must be used in order to allow sourcing from a function ([b_import](#b_import))
#+ #.   modules must implement a function such as
#+      *b\_\[module\]\_getDeps*
#+      *returns*: newline-separated list of dependencies of the module
#+ #.   modules should provide a header similar to that of the blib source file in order to make the documentation generation work
#+ #.   modules may be placed in subfolders of arbitrary depth
#+ #.   use 0 to indicate true and 1 to indicate false for variables; for exit codes use a non-zero exit code to indicate the number of errors
#+ #.   functions should be tagged with the following tags, if applicable:
#+      *@StateChanging* - the function changes the internal state of the script in a way that will not propagate to supershells (e.g. global variables) and should thus not be called from subshells (unless the user wants the state to only change in that shell)
#+      *@B_E* - the function uses [B_E](#B_E) for error handling and may thus behave differently depending on the implemented error handler
#+
#+### Library Usage ###
#+with the default bash options:
#+```bash
#+ source blib
#+ b_import [module]
#+```
#+

#+### Global Variables ###

#map to store global blib data (we use it to hide global variables from the namespace)
#meant for data that may cause stateless testing with [runSL](#runSL) to fail (i.e. state changes here are monitored)
#most module data should go here
declare -gA BLIB_STORE
BLIB_STORE=(
	["BLIB_SCRIPT_DIR"]="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
	["BLIB_SCRIPT_NAME"]="blib"
	["BLIB_LIB_DIR"]="${BLIB_STORE["BLIB_SCRIPT_DIR"]}/lib"
	["BLIB_DOC_DIR"]="${BLIB_STORE["BLIB_SCRIPT_DIR"]}/doc"
	["BLIB_TESTS_DIR"]="${BLIB_STORE["BLIB_SCRIPT_DIR"]}/tests"
	["BLIB_STATIC_DOC_DIR"]="${BLIB_STORE["BLIB_SCRIPT_DIR"]}/doc_static"
	["BLIB_IMPORTED_MODULES"]=""
	["BLIB_STANDALONE_MODE"]="1"
	)
#BLIB_STANDALONE_MODE: set to 0 if this script is a standalone version generated by b_generateStandalone

#another map to store global blib data
#meant for data that changes quite frequently, but shouldn't cause stateless testing with [runSL](#runSL) to fail (i.e. state changes here are _not_ monitored)
declare -gA BLIB_STORE_VOLATILE
BLIB_STORE_VOLATILE=(
	["BLIB_MODULE_LIST_CACHE"]=""
	["BLIB_CB_REF_LIST_CACHE"]=""
	["BLIB_ERR_ESET"]=""
	["BLIB_ERR_HANDLER"]="b_defaultErrorHandler"
	)
#BLIB_ERR_*: used by B_E

#last element = event handler in use before the last call to [b_setErrorHandler](#b_setErrorHandler)
declare -ga BLIB_ERR_HANDLER_LAST=()

#+B_TEST_MODE
#+blib will set this variable to 0, if blib is running in test mode.
#+This variable may be used to bypass code during testing, if bats cannot test that code due to its limitations (e.g. for EXIT traps which bats uses for itself).
B_TEST_MODE=1

#+B_CALLER_NAME
#+Name of the executable or script as String which called blib and any child libraries.
B_CALLER_NAME="${0##*/}"

#+B_ERR
#+Global variable used for error handling throughout blib, cf. [B_E](#B_E).
#+
#+It is recommended to always set an at least partially static error message on confirmed errors as variables may be empty (which would indicate "no error" for [B_E](#B_E)).
B_ERR=""

#+B_RC
#+Can be used to set the return code for [B_E](#B_E) in the case of an error. It defaults to 1.
#+
#+This should be set to an integer value between 1 and 255. Any other value may cause undefined behaviour.
B_RC=1

#+B_LIB_DIR
#+Path of the blib installation directory.
B_LIB_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"

#+B_SCRIPT
#+Global variable which can be used to obtain the two global variables [B_SCRIPT_DIR](#B_SCRIPT_DIR) and [B_SCRIPT_NAME](#B_SCRIPT_NAME) as follows:
#+```bash
#+eval "$B_SCRIPT"
#+```
B_SCRIPT=""_
read -r -d '' B_SCRIPT << 'EOF'
B_SCRIPT_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
B_SCRIPT_NAME="${BASH_SOURCE[0]##*/}"
EOF
#+
#+B_SCRIPT_NAME
#+Path of the sourced or executed bash script executing the eval (symlinks are resolved) of [B_SCRIPT](#B_SCRIPT).
#+
#+B_SCRIPT_DIR
#+Name of the sourced or executed bash script executing the eval (symlinks are resolved) of [B_SCRIPT](#B_SCRIPT).

#+### Global Aliases ###

#+Alias expansion is automatically enabled by blib as it is required for its core functionality. So if you have strange aliases defined in your shell environment, this may cause undefined blib behaviour.
#aliases should be avoided wherever possible, but sometimes they provide more power than functions
#NOTE: aliases are passed to sourced modules as long as they were defined before
shopt -s expand_aliases

#+B_E
#+*The* blib error handler: All blib modules use it whenever execution errors require special handling that the currently executing code cannot achieve.
#+
#+Syntax:
#+```bash
#+B_ERR="This is an error message." ; B_E ;
#+```
#+If you need to set the return/exit code, you can do it with [B_RC](#B_RC):
#+```bash
#+B_ERR="This is another error message." ; B_RC=6 ; B_E ;
#+```
#+
#+Calling [B_E](#B_E) means:
#+Check [B_ERR](#B_ERR) for an error message and if there is one, handle it. It can be placed at the end of a line or on its own line. [B_E](#B_E) will then process the error message in the way defined by the error handler (cf. [b_defaultErrorHandler](#b_defaultErrorHandler)) and stop any further execution of code in the current context (function, script, ...) returning a non-zero exit code (1) unless the described error was fixed. In the latter unlikely case it'll let execution proceed.
#+
#+The error handler can be re-defined at runtime with [b_setErrorHandler](#b_setErrorHandler).
alias B_E='{
#save exit code
BLIB_STORE_VOLATILE["BLIB_ERR_ESET"]=$?

#error?
if [ -n "$B_ERR" ] ; then
	#call error message handler
	${BLIB_STORE_VOLATILE["BLIB_ERR_HANDLER"]}

	#handle according to spec
	case $? in
	 0)
	   B_ERR=""
	   ;;
	 1)
	   return $B_RC &> /dev/null || exit $B_RC
	   ;;
	 *)
	   exit $B_RC
	 esac
fi

#restore exit code (the && construct is required to bypass the shopt -e mode from erroring out in e.g. bats)
blib_setExitCode "${BLIB_STORE_VOLATILE["BLIB_ERR_ESET"]}" && blib_setExitCode "${BLIB_STORE_VOLATILE["BLIB_ERR_ESET"]}"
}'
#Note: {} groups must always end with a newline or ;

#+### Functions ###

#blib_setExitCode [status]
function blib_setExitCode {
return $1
}

#+b_printStackTrace [skip level]
#+[skip level]: skip that many levels of the stack trace (optional, default: 1 - skip this function call)
#+print the current stack trace in a human readable way
#+returns: stack trace with the first levels skipped as defined
function b_printStackTrace {
local skipLevel="${1:-1}"
local pad=0

local i=
for (( i=$skipLevel; i < $(( ${#FUNCNAME[@]}-1 )); i++ )); do
	local s=$(( $i+1 ))
	local func="${FUNCNAME[$i]}"
	local lineno="${BASH_LINENO[$i]}"
	local src="${BASH_SOURCE[$s]}"
	printf "%${pad}s(%s:%d) %s\n" "" "$src" "$lineno" "$func"
	pad=$(( pad + 2 ))
done
}

#+b_nop
#+Do nothing.
#+returns: nothing; sets a zero exit code
function b_nop {
:
}

#+b_version [part]
#+Get the version of this blib instance.
#+[part]: Optional parameter defining the part of the version to retrieve (0: all as String (default), 1: major as Integer, 2: minor as Integer).
#+returns: blib version as string; always sets a zero exit code
function b_version {
local part="${1:0}"
local major=1
local minor=1

case "$part" in
	1)
	echo "$major"
	;;

	2)
	echo "$minor"
	;;
	
	*)
	echo "${major}.${minor}"
	;;
esac

return 0
}

#+b_defaultErrorHandler [error out] [print stderr] [print stack trace]
#+The blib default error handler.
#+As any error handler it must
#+
#+ #.   handle the error message (if not the error itself) lying in [B_ERR](#B_ERR)
#+ #.   not take any non-numeric arguments
#+ #.   not error out itself
#+ #.   implement the below *\[error out\]* as its first parameter (to make [b_setBE](#b_setBE) work)
#+ #.   return one of the following exit codes:
#+      a) 0: **if and only if** the error was fixed entirely and the caller may ignore the error (i.e. probably never)
#+      b) 1: The error wasn't fixed. Functions should return to their caller indicating an error (non-zero status code). Direct shell calls will exit. [B_ERR](#B_ERR) is **not** reset to blank, i.e. the next call to [B_E](#B_E) in the same context will cause another error. The caller may use this to either *throw* the error further or handle and clear the error.
#+	c) 2: Force a stop of execution in the current shell / error out.
#+
#+[error out]: Whether or not to call exit after the error message handling, if the error couldn't be handled (default: 0 = always error out / call exit). If set to 1, [B_E](#B_E) will allow e.g. functions to return to their callers.
#+[print stderr]: Whether or not to print the error message to stderr (default: 0 = print).
#+[print stack trace]: Whether or not to print a stack trace to stderr (default: 0 = print).
#+returns: see the description above
function b_defaultErrorHandler {
local errorOut=${1:-0}
local printErr=${2:-0}
local printStack=${3:-0}

[ $printErr -eq 0 ] && >&2 echo "ERROR: $B_ERR"

if [ $printStack -eq 0 ] ; then
	local stack="$(b_printStackTrace 1)"
	>&2 echo "Stack Trace:"
	>&2 echo "$stack"
fi

#set the proper exit code
if [ $errorOut -eq 0 ] ; then
	[ $printErr -eq 0 ] && >&2 echo "Aborting..."
	return 2
else
	return 1
fi
}

#+b_setBE [error out]
#+Set the [error out] behaviour of the currently configured error handler.
#+
#+Contrary to [b_setErrorHandler](#b_setErrorHandler) this function may be called by blib modules as all error handlers are required to support [error out] as parameter.
#+
#+Example for switching the error out behaviour:
#+```bash
#+ b_setBE 1
#+ funcThatMayCallB_E #without subshell
#+ ret=$?
#+ b_resetErrorHandler
#+```
#+[error out]: see [b_defaultErrorHandler](#b_defaultErrorHandler) (default: 0)
#+returns: nothing, always sets a zero exit code
#+@StateChanging
function b_setBE {
local errOut=${1:-0}
b_setErrorHandler "${BLIB_STORE_VOLATILE["BLIB_ERR_HANDLER"]} $errOut"
}

#+b_setErrorHandler [handler]
#+Set the error handler for all future exections of [B_E](#B_E) in the current scope.
#+
#+You can do this in e.g. subshells to limit the effect.
#+
#+blib modules should only use this function if absolutely necessary to temporarily modify the error behaviour whilst making sure that [b_resetErrorHandler](#b_resetErrorHandler) is called in the end. Otherwise it will prevent library users from setting the general behaviour in their scripts.
#+
#+Usually you do not want to write an entirely new handler, but modify the [b_defaultErrorHandler](#b_defaultErrorHandler) parameters with this setter or use [b_setBE](#b_setBE) for that.
#+[handler]: Function to handle errors. See [b_defaultErrorHandler](#b_defaultErrorHandler) for details.
#+returns: nothing
#+@StateChanging
function b_setErrorHandler {
BLIB_ERR_HANDLER_LAST+=( "${BLIB_STORE_VOLATILE["BLIB_ERR_HANDLER"]}" )
BLIB_STORE_VOLATILE["BLIB_ERR_HANDLER"]="$1"
}

#+b_resetErrorHandler
#+Set the error handler to whatever it was before the last call to [b_setErrorHandler](#b_setErrorHandler) or [b_setBE](#b_setBE).
#+returns: nothing, always sets a zero exit code
#+@StateChanging
function b_resetErrorHandler {
local lastInd=$(( ${#BLIB_ERR_HANDLER_LAST[@]} -1 ))
local last="b_defaultErrorHandler"
if [ $lastInd -ge 0 ] ; then
	last="${BLIB_ERR_HANDLER_LAST[$lastInd]}"
	unset BLIB_ERR_HANDLER_LAST[$lastInd]
fi
BLIB_STORE_VOLATILE["BLIB_ERR_HANDLER"]="$last"
return 0
}

#+b_getErrorHandler
#+Get the currently for [B_E](#B_E) configured error handler.
#+returns: the error handler function
function b_getErrorHandler {
echo "${BLIB_STORE_VOLATILE["BLIB_ERR_HANDLER"]}"
}

#+b_silence [function] [param 1] .. [param p]
#+Call the given function with its parameters in the current shell context whilst suppressing all of its output to both stdout and stderr. Anything written to [B_ERR](#B_ERR) however is passed to [B_E](#B_E) (which can still write to stderr).
#+
#+This function is useful when you want to keep an error message set with [B_ERR](#B_ERR), but discard everything else.
#+In contrast `yourfunction &> /dev/null`{.bash} may also drop the error message, if you're using an error handler (see [B_E](#B_E)) that writes to stdout or stderr.
#+[function]: The function to execute.
#+[param p]: An arbitrary number of function parameters.
#+returns: Sets the status code of the called function, but doesn't print anything. [B_E](#B_E) is called on errors.
#+@B_E
function b_silence {
#we use b_setBE 1 to retrieve the B_ERR message if there's any
local ret=
b_setBE 1
blib_execFuncInCurrentContext "$@" &> /dev/null
ret=$?
b_resetErrorHandler
B_E
return $ret
}

#+b_info [message]
#+Print the given message to stdout as info message.
#+[message]: to print to stdout
#+returns: nothing
function b_info {
echo "INFO: $1"
}

#+b_enforceUser [user name]
#+enforce that the user is the given one and if not, exit the script and set a non-zero status code
#+[user name]: user name to check against
#+returns: nothing
#+@B_E
function b_enforceUser {
local user="$1"
[ "$(whoami)" != "$user" ] && B_ERR="This script must be run as ${user}." && B_E
return 0
}

#+b_isFunction [potential function name]
#+check whether the given function is defined
#+returns: zero exit code if the function is defined
function b_isFunction {
declare -Ff "$1" > /dev/null
#the exit code is returned
}

#blib_getBlibModules [path] [prefix]
#[path]: path to the module directory
#[prefix]: optional prefix to remove (default = path) from the output
#recurse the given path for blib modules
#returns: all available blib module names as newline-separated list
function blib_getBlibModules {
local path="$1"
local prefix="${2:-$path}"
[[ "$prefix" != *"/" ]] && prefix="${prefix}/"
local ret=""

for file in "$path"/* ; do
	local fname="${file#"$prefix"}"

	if [ -f "$file" ] ; then
		[ -n "$ret" ] && ret="$ret"$'\n'
		ret="$ret$fname"
	elif [ -d "$file" ] ; then
		[ -n "$ret" ] && ret="$ret"$'\n'
		ret="$ret$( blib_getBlibModules "$file" "$prefix" )"
	else
		continue
	fi
done

echo "$ret"
}

#+b_getBlibModules
#+get all available blib module names as a newline-separated list
#+returns: all available blib module names as newline-separated list
function b_getBlibModules {
#only compute if not in cache
if [ -z "${BLIB_STORE_VOLATILE["BLIB_MODULE_LIST_CACHE"]}" ] ; then
	local ret="${BLIB_STORE_VOLATILE["BLIB_SCRIPT_NAME"]}"
	ret="$ret"$'\n'"$(blib_getBlibModules "${BLIB_STORE["BLIB_LIB_DIR"]}")"
	BLIB_STORE_VOLATILE["BLIB_MODULE_LIST_CACHE"]="$(echo "$ret" | sort)"
fi
echo "${BLIB_STORE_VOLATILE["BLIB_MODULE_LIST_CACHE"]}"
}

#blib_getModulePath [module]
#get the module path
#[module]: name of the module
#returns: path to the module; sets a non-zero exit code on errors (incl. when the module path does not exist)
#@B_E
function blib_getModulePath {
local module="$1"
local retDir=""

#check for special case where the module is blib itself
if [[ "$module" == "${BLIB_STORE["BLIB_SCRIPT_NAME"]}" ]] ; then
	retDir="${BLIB_STORE["BLIB_SCRIPT_DIR"]}"
else
	retDir="${BLIB_STORE["BLIB_LIB_DIR"]}"
fi

local ret="$retDir/$module"
[ ! -f "$ret" ] && B_ERR="The module $module cannot be found at $ret or is inaccessible." && B_E
echo "$ret"
}

#+b_listContains [list] [entry]
#+check whether the given list contains the given entry
#+[list]: newline-separated list
#+[entry]: string to be found on a single line within the list (equality check)
#+returns: a zero exit code if the list contains the entry; a non-zero exit code otherwise
function b_listContains {
local list="$1"
local entry="$2"

local line=""
while IFS= read -r line ; do
	[[ "$line" == "$entry" ]] && return 0
done <<< "$list"

return 1
}

#+b_checkDeps [list]
#+check whether the given list of dependencies is met by the system running this function.
#+[list]: newline-separated list of binaries or commands that the system must be able to execute
#+returns: list of dependencies not met; a non-zero exit code is set, if the list contains elements
function b_checkDeps {
local depList="$1"
local ret=""

local bin=""
while IFS= read -r bin ; do
	[ -z "$bin" ] && continue
	command -v "$bin" &> /dev/null || ret="${ret}${bin}"$'\n'
done <<< "$depList"

#return & set exit code
echo -n "$ret"
[ -z "$ret" ]
}

#+b_blib_getDeps
#+Get the dependencies of this module.
#+returns: newline-separated list of dependencies of this module
function b_blib_getDeps {
local deps=""
read -r -d '' deps << 'EOF'
dirname
readlink
whoami
sort
cat
mktemp
rm
su
EOF

echo -n "$deps"
}

#blib_getModuleImports [module] [markdown link]
#get the list of other modules that the given module imports via b_import (in its header)
#[module]: module to check the imports for; may be a relative path
#[markdown link]: whether or not to print the output as markdown link (default: 1/false)
#returns: newline-separated list of imports of the given module; sets a non-zero status code on errors
#@B_E
function blib_getModuleImports {
local module="$1"
local markLink="${2:-1}"
local modulePath=""
modulePath="$(blib_getModulePath "$module")" || { B_ERR="Failed to obtain the path for the module $module."; B_E; }
#NOTE: space in front of b_import will make the below ignore it (this is meant to allow for dynamic imports not to be reported as e.g. below)
local importRegex='^b_import[[:blank:]]+(.*)$'
local import=""

local outFormat='%s\n'
[ $markLink -eq 0 ] && outFormat=' [%s]\n\n'

#unfortunately we need str here
 b_import str

local line=""
while IFS= read -r line ; do
	if [[ "$line" =~ $importRegex ]] ; then
		import="$(b_str_stripQuotes "${BASH_REMATCH[1]}")"
		printf "$outFormat" "$import"
	fi
done < "$modulePath"

return 0
}

#blib_getDeps [module] [source = 0|1]
#get the list of dependencies for the given module; the module function to retrieve the dependencies must be available in the current namespace
#[module]: module to check dependencies for; may be a relative path
#[source]: whether (1) or not (0) to source the module before checking dependencies (default: 0 = don't source)
#returns: newline-separated list of dependencies of the given module; sets a non-zero status code on errors
#@B_E
function blib_getDeps {
local module="$1"
local moduleName="${module##*/}"
local toSource="${2:-0}"

#make sure we don't source ourselves
[[ "$moduleName" == "${BLIB_STORE["BLIB_SCRIPT_NAME"]}" ]] && toSource=0

#check the deps
if [ $toSource -eq 1 ] ; then
	local modulePath=""
	modulePath="$(blib_getModulePath "$module")" || { B_ERR="Failed to obtain the path for the module $module."; B_E; }
	source "$modulePath" || { B_ERR="Failed to import the module $module from ${modulePath}."; B_E; }
fi
b_${moduleName}_getDeps || { B_ERR="The module $module doesn't seem to define a dependency getter function or it is not available in the current namespace."; B_E; }

return 0
}

#blib_errorOutOnDepFail [module]
#error out if the self-proclaimed dependencies of the given module are not met
#@B_E
function blib_errorOutOnDepFail {
local module="$1"
local deps=""
deps="$(blib_getDeps "$module")" || { B_ERR="Failed to retrieve the dependencies for the module $module."; B_E; }
local missingDeps=""

#check dependencies
missingDeps="$(b_checkDeps "$deps")"
[ -n "$missingDeps" ] && B_ERR="Missing dependencies for module $module:"$'\n'"$missingDeps" && B_E

return 0
}

#+b_import [module] [double import]
#+Import the given module into the current context.
#+[module]: relative path of the module to import (relative to the blib/lib root directory)
#+[double import]: if set to 1, import the given module regardless of whether it was imported before (default: 0 = don't do duplicate imports)
#+returns: nothing, errors out if the import failed and sets a non-zero status code; if the import was successful or previously done, a zero exit code is set
#+@StateChanging
#+@B_E
function b_import {
local module="$1"
local doubleImport="${2:-0}"
local modulePath=""

#checks
[ $doubleImport -ne 1 ] && b_listContains "${BLIB_STORE["BLIB_IMPORTED_MODULES"]}" "$module" && return 0
[[ "$module" == "${BLIB_STORE["BLIB_SCRIPT_NAME"]}" ]] && B_ERR="Cannot import $module itself." && B_E

#source (in standalone mode everything is in this file here, no need to source)
if [ "${BLIB_STORE["BLIB_STANDALONE_MODE"]}" -ne 0 ] ; then
	modulePath="$(blib_getModulePath "$module")" || { B_ERR="Failed to obtain the path for the module $module."; B_E; }
	source "$modulePath" || { B_ERR="Failed to import the module $module from ${modulePath}."; B_E; }
fi

#check dependencies
blib_errorOutOnDepFail "$module" || B_E

#add to list of imported modules
BLIB_STORE["BLIB_IMPORTED_MODULES"]="${BLIB_STORE["BLIB_IMPORTED_MODULES"]}"$'\n'"$module"

#set a reasonable exit code
return 0
}

function blib_usage {
echo "Usage: blib [command] [command parameters]

blib is a collection of bash functions for easier creation of other scripts. In general blib is meant to be included and not executed directly.

This binary however provides some information to library users.

[command] may be one of:
list 			list all available modules
info [module]		print the description of the given module including all functions and global variables made available by the module
gendoc [-t] [format]	generate the blib code documentation in the given format at "${BLIB_STORE["BLIB_DOC_DIR"]}"
			-t	: include the test code documentation
			[format]: one of raw, pdf, html, man (default: raw)
test [module]		run unit tests for the given module; if no module is specified, run all available unit tests
help			print this help
version			print the blib version"
exit 1
}

#+b_generateStandalone [function] [param 1] .. [param p] - [module dep 1] .. [module dep n] - [function dep 1] .. [function dep d]
#+Create a standalone variant of blib in a single file running the given function when called (sourcing that file will only make the functions available) and print that file to stdout.
#+
#+The current execution state is not retained.
#+[function]: The function to call when the generated script is executed. All script parameters when calling \[output file\] are passed to this function. The function must be available in the current context.
#+[param p]: Static parameters to add to the function as single String. Dynamic parameters should be passed to the generated script.
#+[module dep i]: Names of the modules to include in the standalone file. They do not need to be imported.
#+[-]: Dash used as separator between the function dependencies and the modules. If none is provided, all parameters are assumed to be modules.
#+[function dep j]: An arbitrary number of functions that need to be added in order to satisfy the dependencies of the function to call (e.g. if function A is meant to be called, but uses function B internally, you'll have to pass B as one of its dependencies). Dependencies that can be found in added modules should *not* be added.
#+returns: Sets a zero exit code and prints the output file to stdout on success. May error out otherwise.
#+@B_E
function b_generateStandalone {
local func="$1"
local dep=""
local mod=""
local modulePath=""
local par=""
shift

#parse params (printf '%q' escapes) & generate the function call
local funcCall="$func"
for par in "$@" ; do
	[[ "$par" == "-" ]] && shift && break
	printf -v par '%q' "$par"
	funcCall="$funcCall $par"
	shift
done

#parse blib, add the function call instead of blib_main or whatever else there is (we might be calling b_generateStandalone from standalone mode)
local mainCnt=0
local inMain=1
local main=""
local line=
while IFS= read -r line ; do
	if [ $inMain -eq 0 ] ; then
		if [[ "$line" == "#BLIB_MAIN_END" ]] ; then
			main="$main"$'\n'"$line"
			inMain=1
		elif [[ "$line" == *'"$@"' ]] ; then
			main="$main"$'\n'"	$funcCall"' "$@"'
		else
			main="$main"$'\n'"$line"
		fi
	elif [[ "$line" == "#BLIB_MAIN_BEGIN" ]] ; then
		main="$main"$'\n'"$line"
		inMain=0
		mainCnt=$(( $mainCnt +1 ))
	else
		echo "$line"
	fi
done < "${BASH_SOURCE[0]}"
[ $mainCnt -ne 1 ] && B_ERR="Failed to find the blib_main call." && B_E
[ $inMain -ne 1 ] && B_ERR="Failed to find the MAIN_END marker." && B_E

#set standalone mode (must be as early as possible as e.g. static imports may happen with the modules below)
echo ""
echo 'BLIB_STORE["BLIB_STANDALONE_MODE"]="0"'

#add modules
for mod in "$@" ; do
	[[ "$mod" == "-" ]] && shift && break
	
	if [ ${BLIB_STORE["BLIB_STANDALONE_MODE"]} -ne 0 ] ; then
		#we only add module content in normal mode (in standalone they either were added before or won't be found)
		modulePath="$(blib_getModulePath "$mod")" || { B_ERR="Failed to obtain the path for the module $mod."; B_E; }
		echo ""
		cat "$modulePath" || { B_ERR="Failed to read $modulePath."; B_E; }
	fi
	shift
done

#add function dependencies
for dep in "$@" ; do
	echo ""
	declare -f "$dep" || { B_ERR="Failed to find the declaration for the function $dep."; B_E; }
done

#add function
echo ""
declare -f "$func" || { B_ERR="Failed to find the declaration for the function $func."; B_E; }

#add call to func
echo ""
echo "$main"

return 0
}

#blib_execFuncInCurrentContext [b_execFuncAs parameters except for user]
#Executes the given function in the current context. Helper for [b_execFuncAs](#b_execFuncAs) and [b_silence](#b_silence).
#returns: see [b_execFuncAs](#b_execFuncAs)
function blib_execFuncInCurrentContext {
local func="$1"
shift
local par=""
local mod=""

#parse params (printf '%q' escapes) & generate the function call
local funcCall="$func"
for par in "$@" ; do
	[[ "$par" == "-" ]] && shift && break
	printf -v par '%q' "$par"
	funcCall="$funcCall $par"
	shift
done

for mod in "$@" ; do
	[[ "$mod" == "-" ]] && shift && break
	b_import "$mod" || B_E
	shift
done

eval "$funcCall"
}

#+b_execFuncAs [user] [function] [param 1] .. [param p] - [module dep 1] .. [module dep n] - [function dep 1] .. [function dep d]
#+Attempt to execute the Bash function as the given user.
#+
#+Whether or not this works highly depends on the underlying OS and its (sudo & su) configuration. In particular this function may cause further execution to wait for the user to type in the password of the requested user.
#+
#+If the given user is identical to the current user, [b_execFuncAs](#b_execFuncAs) may decide to run the function in the current context. Otherwise it may run in a different process.
#+[user]: User to execute the function as (default: root).
#+[function]: The function to execute.
#+[param p]: An arbitrary number of function parameters.
#+[-]: A dash as separator character between the various parameters.
#+[module dep i]: Names of the modules required by the function. They do not need to be imported by the function itself.
#+[function dep j]: An arbitrary number of functions that need to be added in order to satisfy the dependencies of the function to call (e.g. if function A is meant to be called, but uses function B internally, you'll have to pass B as one of its dependencies). Dependencies that can be found in added modules should *not* be added.
#+returns: Whatever the executed function returns. A non-zero exit code may also indicate that the user switch didn't work. In particular [B_E](#B_E) is *not* called if the executed function returns an error.
#+@B_E
function b_execFuncAs {
local user="${1:-root}"
local func="$2"
shift
shift
local eFile=""
local ret=""

local curUser=""
curUser="$(whoami)" || { B_ERR="Failed to identify the current user."; B_E; }

#can we stay in the current context?
if [[ "$curUser" == "$user" ]] ; then
	blib_execFuncInCurrentContext "$func" "$@"
	return $?
fi

#generate the file to execute
eFile="$(mktemp)" || { B_ERR="Failed to create a temp file."; B_E; }
b_generateStandalone "$func" "$@" > "$eFile" || B_E

#escaped versions
#Note: unfortunately the parameter expansion syntax "${var@Q}" is only available with bash 4.4+
local eFileEsc=""
local userEsc=""
printf -v eFileEsc '%q' "$eFile"
printf -v userEsc '%q' "$user"

#run it as the target user
#Notes:
# - Linux won't allow us to change our own process permissions
# - sudo is usually the better choice if available (as it is more likely to be able to run without password prompt)
# - su should always be available (& is a blib dependency)
local cmd=
if command -v sudo &> /dev/null ; then
	cmd="sudo -u ${userEsc} bash $eFileEsc"
else
	cmd="su -c 'bash $eFileEsc' ${userEsc}"
fi

#execute, but don't call B_E
eval "${cmd}"
ret=$?

#cleanup
rm -f "$eFile" &> /dev/null

return $ret
}

#blib_docBeginCallback [document output file] [document output format]
#Callback function for doc generation.
function blib_docBeginCallback {
local header=""
local outFormat="$2"
local version="$(b_version)"
read -r -d '' header << 'EOF'
---
title: 'blib Code Reference vVERSION'
author: 'David Hobach'
rights: '(C) 2018  David Hobach  CC BY-NC'
lang: 'en'
header: 'blib Code Reference'
section: 3
---
EOF
header="${header/VERSION/$version}"
echo "$header"

if [[ "$outFormat" == "man" ]] ; then
read -r -d '' header << 'EOF'
# NAME #

blib - a bash library

# DESCRIPTION #

The following is a list of modules, their functions and global variables as they are made available by blib. For the command-line help, please execute blib directly.
EOF
echo "$header"
fi
}

#blib_docFileFilterCallback [file list]
function blib_docFileFilterCallback {
local files="$1"
local cur=""

while IFS= read -r cur ; do
	local fname="${cur##*/}"
	if [[ "$cur" != *"/tests/fixtures/"* ]] && [[ "$fname" != "user_test_data.bash" ]] && [[ "$fname" != .* ]] ; then
		echo "$cur"
	fi
done <<< "$files"
}

#+b_isModule [module name]
#+Test whether the given name represents a blib module name.
#+returns: sets a zero exit code if the given name is a valid module name
function b_isModule {
local modTest="$1"
#execute in subshell to avoid error out:
$(blib_getModulePath "$modTest" &> /dev/null)
}

#blib_getFileDocId [file path]
#[file path]: path for which to get the documentation ID
#returns: The documentation ID for that file (is the module name if the file is a module).
function blib_getFileDocId {
local filePath="$1"

local fileId="${filePath#"${BLIB_STORE["BLIB_LIB_DIR"]}"}"
fileId="${fileId#"${BLIB_STORE["BLIB_SCRIPT_DIR"]}"}"
[[ "$fileId" == /* ]] && fileId="${fileId#/}"

echo "$fileId"
}

#blib_docEndCallback [document file] [document output format]
function blib_docEndCallback {
echo ""
echo "## Reference List ##    {#reflist}"
echo ""

BLIB_STORE_VOLATILE["BLIB_CB_REF_LIST_CACHE"]="$(echo "${BLIB_STORE_VOLATILE["BLIB_CB_REF_LIST_CACHE"]}" | sort)"

local ref=""
while IFS= read -r ref ; do
	[ -n "$ref" ] && echo "[$ref](#$ref)"$'\n'
done <<< "${BLIB_STORE_VOLATILE["BLIB_CB_REF_LIST_CACHE"]}"
}

#blib_docPostProcessingCallback [init target] [input] [file] [document output format]
function blib_docPostProcessingCallback {
local initTarget="$1"
local input="$2"
local filePath="$3"
local docId="$(blib_getFileDocId "$filePath")"

echo ""
echo "## $docId ##"
echo ""

#gendoc init target
if [ $initTarget -eq 0 ] ; then
	#blib doc syntax --> markdown
	#NOTE: [:blank:]* in front of these regexes is explicitly *not* supported in order not to break whitespace-related markdown functionality (e.g. verbatim blocks, fenced code blocks, ...)
	local funcParRegex='^\[([^]]+)\](.*)$'
	#@funcRegex: __[name] may also indicate a function named [name] (if no prefix is used in e.g. test environments)
	local funcRegex='^(([a-z]_|__)[^[:blank:]]+).*$'
	local varRegex='^([A-Z_0-9]+)$'
	local headerRegex='^(#+)[^#].*$'
	local returnsRegex='^returns\:'
	local funcAnnotateRegex='^(@[a-zA-Z_\-]+)[[:blank:]]*$'
	local headerLevel=4

	#read file
	local line=""
	while IFS= read -r line ; do

		#escape all [] for function & global variable names
		if [[ "$line" =~ $funcRegex ]] || [[ "$line" =~ $varRegex ]] ; then
			line="${line//\[/\\\[}"
			line="${line//\]/\\\]}"

			local name="${BASH_REMATCH[1]}"

			#remove __ prefix for non-prefixed variables or functions
			line="${line#__}"
			name="${name#__}"

			local headerIndent=""
			for ((i=0; i < headerLevel; i++)) ; do headerIndent="${headerIndent}#" ; done
			#set an explicit header ID (= name)
			line="$headerIndent $line $headerIndent    {#$name}"

			#add to func list for further processing by doc end callback
			BLIB_STORE_VOLATILE["BLIB_CB_REF_LIST_CACHE"]="${BLIB_STORE_VOLATILE["BLIB_CB_REF_LIST_CACHE"]}$name"$'\n'
			#print full name
			line="$line"$'\n'"<small>*${docId}/${name}*</small>"$'\n'

		#escape the first [] for parameters, further [] may be used for links
		#we also add an html identifier
		elif [[ "$line" =~ $funcParRegex ]] ; then
			line=$'\n''<span class="par">'"\[${BASH_REMATCH[1]}\]${BASH_REMATCH[2]}"'</span>'

		elif [[ "$line" =~ $headerRegex ]] ; then
			headerLevel=$(( ${#BASH_REMATCH[1]} +1))

		#make "returns" bold in function doc
		#we also add an html identifier
		elif [[ "$line" =~ $returnsRegex ]] ; then
			line=$'\n''<span class="ret">'"${line/returns:/**returns**:}"'</span>'

		#change @ annotations to italic
		#we also add an html identifier
		elif [[ "$line" =~ $funcAnnotateRegex ]] ; then
			line=$'\n''<span class="ann">'"${line/${BASH_REMATCH[1]}/*${BASH_REMATCH[1]}*}"'</span>'
		fi

		echo "$line"
	done <<< "$input"
else
	#command-line init target = no modifications
	echo "$input"
fi
}

#blib_docSpaceCallback [matching line] [file] [previous space count] [document output format]
function blib_docSpaceCallback {
local filePath="$2"
local prevCnt=$3

local fileId="$(blib_getFileDocId "$filePath")"

#add dependencies & imports after description
if [ $prevCnt -eq 0 ] ; then
	if b_isModule "$fileId" ; then
		local deps=""
		#NOTE: this _will_ source all available modules...
		#maybe TODO: use a more lightweight method
		deps="$(blib_getDeps "$fileId" 1 2> /dev/null)"
		if [ $? -eq 0 ] ; then
			[ -z "$deps" ] && deps="no dependencies"
			echo ""
			echo "### Dependencies ###"
			echo "$deps"
		fi

		local imports=""
		imports="$(blib_getModuleImports "$fileId" 0 2> /dev/null)"
		if [ $? -eq 0 ] && [ -n "$imports" ] ; then
			echo ""
			echo "### Imports ###"
			echo "$imports"
		fi
		echo ""
	fi
else
	echo ""
fi
}

#blib_initCdoc [init target]
#[init target]: if set to 0, init for gendoc (default); if set to 1, init for a command-line output
#Init cdoc with the parameters requires for its usage within blib.
function blib_initCdoc {
local initTarget="${1:-0}"

 b_import cdoc

#set cdoc callback functions for all init targets
b_cdoc_setSpaceCallback "blib_docSpaceCallback"
b_cdoc_setPostProcessingCallback "blib_docPostProcessingCallback $initTarget"

if [ $initTarget -eq 0 ] ; then
	#gendoc target:
	b_cdoc_setDocumentBeginCallback "blib_docBeginCallback"
	b_cdoc_setDocumentEndCallback "blib_docEndCallback"
	b_cdoc_setFileFilterCallback "blib_docFileFilterCallback"
fi
}

#see usage
function blib_gendoc {
local includeTestDoc=1
if [[ "$1" == "-t" ]] ; then
	includeTestDoc=0
	shift
fi
local outFormat="${1:-raw}"

local cdocInput="${BLIB_STORE["BLIB_SCRIPT_DIR"]}/${BLIB_STORE["BLIB_SCRIPT_NAME"]}"$'\n'"${BLIB_STORE["BLIB_LIB_DIR"]}"
local cdocOutput="${BLIB_STORE["BLIB_DOC_DIR"]}/blib"

if [ $includeTestDoc -eq 0 ] ; then
	cdocInput="$cdocInput"$'\n'"${BLIB_STORE["BLIB_TESTS_DIR"]}"
	cdocOutput="${cdocOutput}_test"
fi

blib_initCdoc

#generate the doc
local outPath=""
echo -n "Generating $outFormat documentation...  "
outPath="$(b_cdoc_generateBlibStyle "$cdocInput" "$cdocOutput" "$outFormat")" || { B_ERR="Failed to generate the $outFormat documentation."; B_E; }
echo "Done."
echo "${outPath}"
}

#see usage
function blib_test {
local module="$1"
local testDir="${BLIB_STORE["BLIB_SCRIPT_DIR"]}/tests"

b_checkDeps "bats" || { B_ERR="bats is not installed."; B_E; }
b_checkDeps "find" || { B_ERR="find is not installed."; B_E; }

B_TEST_MODE=0

if [ -z "$module" ] ; then
	local ret=0
	local testFiles=0

	local tst=""
	while IFS= read -r tst ; do
		echo ""
		echo "${tst##$testDir/}"
		bats -p "$tst"
		ret=$(( $ret + $?))
		testFiles=$(( $testFiles +1 ))
	done <<< "$(find "$testDir" -name "*.bats" | sort)"

	[ $testFiles -le 2 ] && B_ERR="Failed to find any relevant tests." && B_E

	echo ""
	echo "#FAILED TEST FILES: $ret / $testFiles"
	exit $ret
else
	bats "$testDir/$module.bats"
	exit $?
fi
}

#see usage
function blib_info {
local module="$1"
local modulePath=""

modulePath="$(blib_getModulePath "$module")" || { B_ERR="Invalid or non-existing module: $module"; B_E; }

blib_initCdoc 1

local outPath="$(mktemp -u)"
b_cdoc_generate "$modulePath" "$outPath"
cat "$outPath" || { B_ERR="Failed to read ${outPath}."; B_E; }

#cleanup
rm -f "$outPath" || { B_ERR="Failed to remove ${outPath}."; B_E; }

return 0
}

#blib_getModuleDescription [module]
#get a short description for each module parsed from its source
#@B_E
function blib_getModuleDescription {
local module="$1"
local modulePath=""
modulePath="$(blib_getModulePath "$module")" || { B_ERR="Failed to obtain the path for the module $module."; B_E; }

#by convention, a short description should be found in the first few non-empty comment lines of a module followed by an empty line
local lineNo=0
local regex='^#\+(.*)$'
local descriptionSeen=0
local line=""
while IFS= read -r line ; do

	#skip after a while
	[ $lineNo -gt 15 ] && break
	
	#check for non-empty line
	if [[ "$line" =~ $regex ]] ; then
		local extr="${BASH_REMATCH[1]}"

		#skip when copyright is seen
		[[ "$extr" == *Copyright* ]] && break

		echo -n -e "\t"
		echo "$extr"
		descriptionSeen=1
	else
		#are we past the description?
		[ $descriptionSeen -eq 1 ] && break
	fi

	lineNo=$(( lineNo +1))
done < "$modulePath"
}

#see usage
function blib_list {
local mods="$(b_getBlibModules)"

local module=""
while IFS= read -r module ; do
	echo "$module"
	echo "$(blib_getModuleDescription "$module")"
done <<< "$mods"
}

#main (executed when blib is called directly rather than sourced)
function blib_main {
[ $# -lt 1 ] && blib_usage

#parse commands
local cmd="$1"

case "$cmd" in
	list)
	[ $# -ne 1 ] && blib_usage
	blib_list
	;;

	info)
	[ $# -ne 2 ] && blib_usage
	blib_info "$2"
	;;
	
	test)
	[ $# -gt 2 ] && blib_usage
	blib_test "$2"
	;;

	gendoc)
	[ $# -gt 3 ] && blib_usage
	blib_gendoc "$2" "$3"
	;;
	
	version)
	[ $# -ne 1 ] && blib_usage
	b_version
	;;

	*)
	blib_usage
	;;
esac

exit 0
}

#check dependencies
blib_errorOutOnDepFail "blib" || B_E

#check bash version
#currently at least 4.2 is needed for declare -gA support
[ ${BASH_VERSINFO[0]} -lt 4 ] || ( [ ${BASH_VERSINFO[0]} -eq 4 ] && [ ${BASH_VERSINFO[1]} -lt 2 ] ) && B_ERR="blib only works with bash versions >= 4.2" && B_E

#BLIB_MAIN_BEGIN
#NOTE: the above comment and the below format are required for b_generateStandalone
#are we called directly?
if [[ "${BASH_SOURCE[0]}" == "$0" ]] ; then
	blib_main "$@"
else
	#if not, set a zero exit code to indicate a successful source call
	:
fi
#BLIB_MAIN_END
